#include <fstream>
#include <string>
#include <iostream>

int main()
{
	
    std::string input=std::string("");
    
    input+="//THIS FILE IS PROCEDURALY GENERATED BY 'TypelistGENERATO.cpp' IF THE PRESENT TYPELIST ARE TO SHORT GO THERE RECOMPILE USING A BIGGER 'int depth'\n\
//USE OF THIS : namespace CONDITIONAL_TEXT {typedef TYPELIST((float, double, int, unsigned int, std::string)) CONDITIONAL_TEXT_TYPE;} \n\n\
#pragma once \n\
namespace CONDITIONAL_TEXT { \n\
class null_typelist {};\n\
template <class H, class T>\n\
struct typelist\n\
{\n\
	typedef H head;\n\
	typedef T tail;\n\
};\n\
template <class Fun> struct cons;\n";
    
    
    int depth=30;
    
    int i=1;
    while(i<depth){
    		
		input+="template <";
		for( int a =0; a < i; a++ )input+="class T"+std::to_string(a)+",";
		input=input.substr(0, input.size()-1);	
		input+=">   struct cons<void(*)(";
		for( int a =0; a < i; a++ )input+="T"+std::to_string(a)+",";
		input=input.substr(0, input.size()-1);
		input+=")>\n";
		input+="{\n\n";
		
		std::string substr("null_typelist");
		for( int a =i-1; a > -1; a-- ) substr = "typelist<T"+std::to_string(a)+","+substr+">" ;
		
		substr="	typedef "+substr+" type;\n\n";
		
		input+=substr;
		
		input+="};\n";
		
    	i++;
	}

    input+="\n\n#define TYPELIST(a) cons< void (*)a >::type\n\n";
    
    input+="}";
    std::ofstream out("TYPELIST.h");
    out << input;
    out.close();
    return 0;
}
